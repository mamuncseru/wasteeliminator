"use strict";
// Initial script taken from
// https://docs.microsoft.com/en-us/bingmaps/v8-web-control/creating-and-hosting-map-controls/creating-a-basic-map-control
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleNames = exports.loadModule = exports.getApiUrl = exports.initializeSSR = exports.whenLoaded = exports.initialize = void 0;
var CALLBACK_NAME = "GetMapCallback";
var LOADED_CHECK = "MicrosoftMapsLoaded";
var inBrowser = function () {
    return typeof window !== "undefined";
};
var mapsLoaded = function () {
    return inBrowser() && window[LOADED_CHECK];
};
var initialized = false;
var resolver;
var rejecter;
var getApiUrl = function (apiKey) {
    return "https://www.bing.com/api/maps/mapcontrol?callback=" + CALLBACK_NAME + "&key=" + apiKey;
};
exports.getApiUrl = getApiUrl;
/**
 * Fire off the request to load the API
 * @param apiKey
 * @param modulesToLoad Use the Module names list to populate
 */
var initialize = function (apiKey) {
    var modulesToLoad = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        modulesToLoad[_i - 1] = arguments[_i];
    }
    if (!inBrowser()) {
        throw Error("Bing Maps Loader :: Not running in a browser \n Call initializeSSR() in combination with getApiUrl(). Info in the bing-maps-loader README ");
    }
    if (mapsLoaded()) {
        return loadModules(modulesToLoad);
    }
    if (!initialized) {
        initialized = true;
        setCallback(modulesToLoad);
        addMapsScriptToHead(apiKey);
    }
};
exports.initialize = initialize;
/**
 * For SSR implementations, the script url + api key will already be in the HTML head.
 * @param modulesToLoad Use the Module names list to populate
 */
var initializeSSR = function () {
    var modulesToLoad = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        modulesToLoad[_i] = arguments[_i];
    }
    if (initialized) {
        return;
    }
    if (inBrowser()) {
        setCallback(modulesToLoad);
    }
    initialized = true;
    //@ts-ignore
};
exports.initializeSSR = initializeSSR;
var setCallback = function (modulesToLoad) {
    var win = window;
    //@ts-ignore
    win[CALLBACK_NAME] = function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadModules(modulesToLoad)];
                case 1:
                    _a.sent();
                    resolver();
                    return [2 /*return*/];
            }
        });
    }); };
    if (mapsLoaded()) {
        win[CALLBACK_NAME]();
        win[CALLBACK_NAME] = null;
    }
};
function loadModules(modulesToLoad) {
    var loadPromises = modulesToLoad.map(function (moduleToLoad) {
        return loadModule(moduleToLoad);
    });
    return Promise.all(loadPromises).then(function () { return Promise.resolve(); });
}
/** Sets up Promises for the CALLBACK
 */
var whenLoaded = new Promise(function (resolve, reject) {
    resolver = resolve;
    rejecter = reject;
});
exports.whenLoaded = whenLoaded;
var addMapsScriptToHead = function (apiKey) {
    var _a;
    var script = document.createElement("script");
    script.async = true;
    script.defer = true;
    script.src = getApiUrl(apiKey);
    script.onerror = rejecter;
    (_a = document.querySelector("head")) === null || _a === void 0 ? void 0 : _a.appendChild(script);
};
var modules = [];
var hasLoaded = function (moduleName) {
    return modules.includes(moduleName);
};
var loadModule = function (moduleName) {
    if (hasLoaded(moduleName)) {
        return Promise.resolve();
    }
    return new Promise(function (resolve) {
        Microsoft.Maps.loadModule(moduleName, function () {
            modules.push(moduleName);
            resolve();
        });
    });
};
exports.loadModule = loadModule;
var moduleNames = {
    AutoSuggest: "Microsoft.Maps.AutoSuggest",
    Clustering: "Microsoft.Maps.Clustering",
    Contour: "Microsoft.Maps.Contour",
    DataBinning: "Microsoft.Maps.DataBinning",
    Directions: "Microsoft.Maps.Directions",
    DrawingTools: "Microsoft.Maps.DrawingTools",
    GeoJson: "Microsoft.Maps.GeoJson",
    GeoXml: "Microsoft.Maps.GeoXml",
    HeatMap: "Microsoft.Maps.HeatMap",
    Search: "Microsoft.Maps.Search",
    SpatialDataService: "Microsoft.Maps.SpatialDataService",
    SpatialMath: "Microsoft.Maps.SpatialMath",
    Traffic: "Microsoft.Maps.Traffic",
    WellKnownText: "Microsoft.Maps.WellKnownText",
    VenueMaps: "Microsoft.Maps.VenueMaps",
};
exports.moduleNames = moduleNames;
